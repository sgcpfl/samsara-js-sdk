/* tslint:disable */
/* eslint-disable */
/**
 * Samsara API
 * <style type=\"text/css\"> n {     padding: 1em;     width: 100%;     display: block;     margin: 28px 0; } n.info {     background-color: rgba(0, 51, 160, 0.1); } n.warning {     background-color: #fdf6e3; } i:before {     margin-right: 6px; } nh {     font-size: 1.5rem;     font-weight: 700;     line-height: 1.1;     display: block; } nb {     margin-top: 10px;     padding-left: 22px;     display: block; } </style>  # Overview  <n class=\"info\"> <nh> <i class=\"fa fa-info-circle\"></i> Something new! </nh> <nb> Welcome Samsara\'s new and improved API. Check out our FAQ [here](https://developers.samsara.com/docs/introducing-our-next-generation-api) to see what\'s changed and learn how to get started.<br> <br> Want to access the legacy API docs? You can find them [here](https://www.samsara.com/api-legacy).<br> <br> *Note: Because this is a new set of APIs, we have not transitioned all endpoints over to this standard. Endpoints that still use the legacy standards are indicated in the reference documentation. If you can\'t find an API that you\'re looking for, we encourage you to look for it in our [legacy API docs](https://www.samsara.com/api-legacy) as we continue to transition all endpoints over. Check back here for updates!*<br> <br> Submit your feedback [here](https://forms.gle/r4bs6HQshQAvBuwv6)! </nb> </n>  Samsara provides API endpoints so that you can build powerful applications and custom solutions with sensor data. Samsara has endpoints available to track and analyze sensors, vehicles, and entire fleets.  The Samsara API is a [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer). It uses standard [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) authentication, verbs, and response codes, and it returns [JSON](http://www.json.org/) response bodies. If you\'re familiar with what you can build with a REST API, then this will be your go-to API reference.  Visit [developers.samsara.com](https://developers.samsara.com) to find getting started guides and an API overview.  If you have any questions, please visit https://samsara.com/help.  ## Endpoints  All our APIs can be accessed through HTTP requests to URLs like:  ``` https://api.samsara.com/<endpoint> ```  For EU customers, this URL will be:  ``` https://api.eu.samsara.com/<endpoint> ```  <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> Note </nh> <nb> Legacy endpoints will have the URL: `https://api.samsara.com/v1/<endpoint>` or `https://api.eu.samsara.com/v1/<endpoint>` </nb> </n>  ## Authentication  To authenticate your API request you will need to include your secret token. You can manage your API tokens in the [Dashboard](https://cloud.samsara.com). They are visible under `Settings->Organization->API Tokens`.  Your API tokens carry many privileges, so be sure to keep them secure. Do not share your secret API tokens in publicly accessible areas such as GitHub, client-side code, and so on.  Authentication to the API is performed via Bearer Token in the HTTP Authorization header. Provide your API token as the `access_token` value in an `Authorization: Bearer` header. You do not need to provide a password:  ```curl Authorization: Bearer {access_token} ```  All API requests must be made over [HTTPS](https://en.wikipedia.org/wiki/HTTPS). Calls made over plain HTTP or without authentication will fail.  ### OAuth2 If building an application for our marketplace, our API is accessible via. OAuth2 as well.  | Type  | Value | | ------------- |:-------------:| | Security scheme      | OAuth2                                   | | OAuth2 Flow          | accessCode                               | | Authorization URL    | https://api.samsara.com/oauth2/authorize | | Token URL            | https://api.samsara.com/oauth2/token     |    ## Common Patterns  You can find more info about request methods, response codes, error codes, versioning, pagination, timestamps, and mini-objects [here](https://developers.samsara.com/docs/common-structures). 
 *
 * The version of the OpenAPI document: 2020-06-15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    DocumentPdfGenerationRequest,
    DocumentPdfGenerationRequestFromJSON,
    DocumentPdfGenerationRequestToJSON,
    DocumentPdfGenerationResponse,
    DocumentPdfGenerationResponseFromJSON,
    DocumentPdfGenerationResponseToJSON,
    DocumentPdfQueryResponse,
    DocumentPdfQueryResponseFromJSON,
    DocumentPdfQueryResponseToJSON,
    StandardErrorResponse,
    StandardErrorResponseFromJSON,
    StandardErrorResponseToJSON,
    V1Document,
    V1DocumentFromJSON,
    V1DocumentToJSON,
    V1DocumentCreate,
    V1DocumentCreateFromJSON,
    V1DocumentCreateToJSON,
    V1DocumentType,
    V1DocumentTypeFromJSON,
    V1DocumentTypeToJSON,
    V1Documents,
    V1DocumentsFromJSON,
    V1DocumentsToJSON,
} from '../models';

export interface DeleteDriverDocumentByIdAndDriverIdRequest {
    driverId: number;
    documentId: string;
}

export interface GenerateDocumentPdfRequest {
    document?: DocumentPdfGenerationRequest;
}

export interface GetDocumentPdfRequest {
    id: string;
}

export interface V1createDriverDocumentRequest {
    driverId: number;
    createDocumentParams: V1DocumentCreate;
}

export interface V1getDriverDocumentByIdAndDriverIdRequest {
    driverId: number;
    documentId: string;
}

export interface V1getDriverDocumentsByOrgIdRequest {
    endMs?: number;
    durationMs?: number;
    queryBy?: V1getDriverDocumentsByOrgIdQueryByEnum;
}

/**
 * 
 */
export class DocumentsApi extends runtime.BaseAPI {

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Deletes a single document submission by driver.
     * Delete a document
     */
    async deleteDriverDocumentByIdAndDriverIdRaw(requestParameters: DeleteDriverDocumentByIdAndDriverIdRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.driverId === null || requestParameters.driverId === undefined) {
            throw new runtime.RequiredError('driverId','Required parameter requestParameters.driverId was null or undefined when calling deleteDriverDocumentByIdAndDriverId.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling deleteDriverDocumentByIdAndDriverId.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/fleet/drivers/{driver_id}/documents/{document_id}`.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters.driverId))).replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Deletes a single document submission by driver.
     * Delete a document
     */
    async deleteDriverDocumentByIdAndDriverId(requestParameters: DeleteDriverDocumentByIdAndDriverIdRequest): Promise<void> {
        await this.deleteDriverDocumentByIdAndDriverIdRaw(requestParameters);
    }

    /**
     * Request creation of a document PDF.
     * Create a document PDF
     */
    async generateDocumentPdfRaw(requestParameters: GenerateDocumentPdfRequest): Promise<runtime.ApiResponse<DocumentPdfGenerationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/fleet/documents/pdfs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentPdfGenerationRequestToJSON(requestParameters.document),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentPdfGenerationResponseFromJSON(jsonValue));
    }

    /**
     * Request creation of a document PDF.
     * Create a document PDF
     */
    async generateDocumentPdf(requestParameters: GenerateDocumentPdfRequest): Promise<DocumentPdfGenerationResponse> {
        const response = await this.generateDocumentPdfRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns generation job status and download URL for a PDF.
     * Query a document PDF
     */
    async getDocumentPdfRaw(requestParameters: GetDocumentPdfRequest): Promise<runtime.ApiResponse<DocumentPdfQueryResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getDocumentPdf.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fleet/documents/pdfs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentPdfQueryResponseFromJSON(jsonValue));
    }

    /**
     * Returns generation job status and download URL for a PDF.
     * Query a document PDF
     */
    async getDocumentPdf(requestParameters: GetDocumentPdfRequest): Promise<DocumentPdfQueryResponse> {
        const response = await this.getDocumentPdfRaw(requestParameters);
        return await response.value();
    }

    /**
     * <n class=\"warning\">   <nh>     <i class=\"fa fa-exclamation-circle\"></i>     This endpoint is still on our legacy API.   </nh> </n>  Create a driver document for the given driver.  You can create a document in one of two states: \"Required\" or \"Submitted\":  - Setting the document state to \"Submitted\" will submit the document on behalf of the driver. - Setting the document state to \"Required\" will create a pre-populated document for the driver to fill out in the Driver App.  **Populating document fields**  You  populate a document\'s fields according to the document\'s *document type*. You can retrieve document types using the [Fetch document types](ref:v1getdriverdocumenttypesbyorgid) endpoint.  You must populate a document\'s fields using the field *labels* and *value types*, and the fields must be listed in the exact same order that they appear in the document type.  **Omitting Field Values**  If you _omit a field\'s **value**_, Samsara will populate the field with a default value. (Note: you must still list the field in your request). For example, the following request omits the `numberValue` for the `\"Number Field\"`.  ``` {   \"documentTypeUuid\": \"79008acc-56d6-49f4-b5d2-4101ce4b497c\",   \"fields\": [     {       \"label\": \"Number Field\",       \"valueType\": \"ValueType_Number\",     }   ] } ```  Samsara will automatically populate the field with the default for number fields: `0`. See the defaults for all field types below.  > Note: The `dateTimeValue` for `ValueType_DateTime` fields **cannot** be omitted. If you\'d like to populate this field with a default datetime value, you must submit `\"dateTimeValue\": {}` for that field.  **Default Field Values**  | Value Type | Field Name | Default value | | :--------- | :--------- | :------------ | | `ValueType_Number` | `numberValue` | `0` | | `ValueType_String` | `stringValue` | `\"\"` | | `ValueType_Photo` | `photoValue` | `[]` | | `ValueType_MultipleChoice` | `multipleChoiceValue` | `[]` | | `ValueType_DateTime` | `dateTimeValue` | `{\"dateTimeMs\": 0}` | | `ValueType_Signature` | `signatureValue` | `{\"name\": \"Name\", \"signedAtMs\": 0, \"url\": \"\"}` | | `ValueType_Barcode` | `barcodeValue` | `[]` |  > Note: `ValueType_ScannedDocument` fields return `ValueType_Photo`/`photoValue` fields, whose default is listed above.
     * Create a document
     */
    async v1createDriverDocumentRaw(requestParameters: V1createDriverDocumentRequest): Promise<runtime.ApiResponse<V1Document>> {
        if (requestParameters.driverId === null || requestParameters.driverId === undefined) {
            throw new runtime.RequiredError('driverId','Required parameter requestParameters.driverId was null or undefined when calling v1createDriverDocument.');
        }

        if (requestParameters.createDocumentParams === null || requestParameters.createDocumentParams === undefined) {
            throw new runtime.RequiredError('createDocumentParams','Required parameter requestParameters.createDocumentParams was null or undefined when calling v1createDriverDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/fleet/drivers/{driver_id}/documents`.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters.driverId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1DocumentCreateToJSON(requestParameters.createDocumentParams),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1DocumentFromJSON(jsonValue));
    }

    /**
     * <n class=\"warning\">   <nh>     <i class=\"fa fa-exclamation-circle\"></i>     This endpoint is still on our legacy API.   </nh> </n>  Create a driver document for the given driver.  You can create a document in one of two states: \"Required\" or \"Submitted\":  - Setting the document state to \"Submitted\" will submit the document on behalf of the driver. - Setting the document state to \"Required\" will create a pre-populated document for the driver to fill out in the Driver App.  **Populating document fields**  You  populate a document\'s fields according to the document\'s *document type*. You can retrieve document types using the [Fetch document types](ref:v1getdriverdocumenttypesbyorgid) endpoint.  You must populate a document\'s fields using the field *labels* and *value types*, and the fields must be listed in the exact same order that they appear in the document type.  **Omitting Field Values**  If you _omit a field\'s **value**_, Samsara will populate the field with a default value. (Note: you must still list the field in your request). For example, the following request omits the `numberValue` for the `\"Number Field\"`.  ``` {   \"documentTypeUuid\": \"79008acc-56d6-49f4-b5d2-4101ce4b497c\",   \"fields\": [     {       \"label\": \"Number Field\",       \"valueType\": \"ValueType_Number\",     }   ] } ```  Samsara will automatically populate the field with the default for number fields: `0`. See the defaults for all field types below.  > Note: The `dateTimeValue` for `ValueType_DateTime` fields **cannot** be omitted. If you\'d like to populate this field with a default datetime value, you must submit `\"dateTimeValue\": {}` for that field.  **Default Field Values**  | Value Type | Field Name | Default value | | :--------- | :--------- | :------------ | | `ValueType_Number` | `numberValue` | `0` | | `ValueType_String` | `stringValue` | `\"\"` | | `ValueType_Photo` | `photoValue` | `[]` | | `ValueType_MultipleChoice` | `multipleChoiceValue` | `[]` | | `ValueType_DateTime` | `dateTimeValue` | `{\"dateTimeMs\": 0}` | | `ValueType_Signature` | `signatureValue` | `{\"name\": \"Name\", \"signedAtMs\": 0, \"url\": \"\"}` | | `ValueType_Barcode` | `barcodeValue` | `[]` |  > Note: `ValueType_ScannedDocument` fields return `ValueType_Photo`/`photoValue` fields, whose default is listed above.
     * Create a document
     */
    async v1createDriverDocument(requestParameters: V1createDriverDocumentRequest): Promise<V1Document> {
        const response = await this.v1createDriverDocumentRaw(requestParameters);
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetches a single document submission by a specific driver.
     * Fetches a document
     */
    async v1getDriverDocumentByIdAndDriverIdRaw(requestParameters: V1getDriverDocumentByIdAndDriverIdRequest): Promise<runtime.ApiResponse<V1Document>> {
        if (requestParameters.driverId === null || requestParameters.driverId === undefined) {
            throw new runtime.RequiredError('driverId','Required parameter requestParameters.driverId was null or undefined when calling v1getDriverDocumentByIdAndDriverId.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling v1getDriverDocumentByIdAndDriverId.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/fleet/drivers/{driver_id}/documents/{document_id}`.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters.driverId))).replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1DocumentFromJSON(jsonValue));
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetches a single document submission by a specific driver.
     * Fetches a document
     */
    async v1getDriverDocumentByIdAndDriverId(requestParameters: V1getDriverDocumentByIdAndDriverIdRequest): Promise<V1Document> {
        const response = await this.v1getDriverDocumentByIdAndDriverIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch all of the document types.
     * Fetch document types
     */
    async v1getDriverDocumentTypesByOrgIdRaw(): Promise<runtime.ApiResponse<Array<V1DocumentType>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/fleet/drivers/document_types`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(V1DocumentTypeFromJSON));
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch all of the document types.
     * Fetch document types
     */
    async v1getDriverDocumentTypesByOrgId(): Promise<Array<V1DocumentType>> {
        const response = await this.v1getDriverDocumentTypesByOrgIdRaw();
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch all of the documents.
     * Fetch all documents
     */
    async v1getDriverDocumentsByOrgIdRaw(requestParameters: V1getDriverDocumentsByOrgIdRequest): Promise<runtime.ApiResponse<V1Documents>> {
        const queryParameters: any = {};

        if (requestParameters.endMs !== undefined) {
            queryParameters['endMs'] = requestParameters.endMs;
        }

        if (requestParameters.durationMs !== undefined) {
            queryParameters['durationMs'] = requestParameters.durationMs;
        }

        if (requestParameters.queryBy !== undefined) {
            queryParameters['queryBy'] = requestParameters.queryBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/fleet/drivers/documents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1DocumentsFromJSON(jsonValue));
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch all of the documents.
     * Fetch all documents
     */
    async v1getDriverDocumentsByOrgId(requestParameters: V1getDriverDocumentsByOrgIdRequest): Promise<V1Documents> {
        const response = await this.v1getDriverDocumentsByOrgIdRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum V1getDriverDocumentsByOrgIdQueryByEnum {
    Created = 'created',
    Updated = 'updated'
}
