/* tslint:disable */
/* eslint-disable */
/**
 * Samsara API
 * <style type=\"text/css\"> n {     padding: 1em;     width: 100%;     display: block;     margin: 28px 0; } n.info {     background-color: rgba(0, 51, 160, 0.1); } n.warning {     background-color: #fdf6e3; } i:before {     margin-right: 6px; } nh {     font-size: 1.5rem;     font-weight: 700;     line-height: 1.1;     display: block; } nb {     margin-top: 10px;     padding-left: 22px;     display: block; } </style>  # Overview  <n class=\"info\"> <nh> <i class=\"fa fa-info-circle\"></i> Something new! </nh> <nb> Welcome Samsara\'s new and improved API. Check out our FAQ [here](https://developers.samsara.com/docs/introducing-our-next-generation-api) to see what\'s changed and learn how to get started.<br> <br> Want to access the legacy API docs? You can find them [here](https://www.samsara.com/api-legacy).<br> <br> *Note: Because this is a new set of APIs, we have not transitioned all endpoints over to this standard. Endpoints that still use the legacy standards are indicated in the reference documentation. If you can\'t find an API that you\'re looking for, we encourage you to look for it in our [legacy API docs](https://www.samsara.com/api-legacy) as we continue to transition all endpoints over. Check back here for updates!*<br> <br> Submit your feedback [here](https://forms.gle/r4bs6HQshQAvBuwv6)! </nb> </n>  Samsara provides API endpoints so that you can build powerful applications and custom solutions with sensor data. Samsara has endpoints available to track and analyze sensors, vehicles, and entire fleets.  The Samsara API is a [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer). It uses standard [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) authentication, verbs, and response codes, and it returns [JSON](http://www.json.org/) response bodies. If you\'re familiar with what you can build with a REST API, then this will be your go-to API reference.  Visit [developers.samsara.com](https://developers.samsara.com) to find getting started guides and an API overview.  If you have any questions, please visit https://samsara.com/help.  ## Endpoints  All our APIs can be accessed through HTTP requests to URLs like:  ``` https://api.samsara.com/<endpoint> ```  For EU customers, this URL will be:  ``` https://api.eu.samsara.com/<endpoint> ```  <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> Note </nh> <nb> Legacy endpoints will have the URL: `https://api.samsara.com/v1/<endpoint>` or `https://api.eu.samsara.com/v1/<endpoint>` </nb> </n>  ## Authentication  To authenticate your API request you will need to include your secret token. You can manage your API tokens in the [Dashboard](https://cloud.samsara.com). They are visible under `Settings->Organization->API Tokens`.  Your API tokens carry many privileges, so be sure to keep them secure. Do not share your secret API tokens in publicly accessible areas such as GitHub, client-side code, and so on.  Authentication to the API is performed via Bearer Token in the HTTP Authorization header. Provide your API token as the `access_token` value in an `Authorization: Bearer` header. You do not need to provide a password:  ```curl Authorization: Bearer {access_token} ```  All API requests must be made over [HTTPS](https://en.wikipedia.org/wiki/HTTPS). Calls made over plain HTTP or without authentication will fail.  ### OAuth2 If building an application for our marketplace, our API is accessible via. OAuth2 as well.  | Type  | Value | | ------------- |:-------------:| | Security scheme      | OAuth2                                   | | OAuth2 Flow          | accessCode                               | | Authorization URL    | https://api.samsara.com/oauth2/authorize | | Token URL            | https://api.samsara.com/oauth2/token     |    ## Common Patterns  You can find more info about request methods, response codes, error codes, versioning, pagination, timestamps, and mini-objects [here](https://developers.samsara.com/docs/common-structures). 
 *
 * The version of the OpenAPI document: 2020-06-15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AssetCreate,
    AssetCreateFromJSON,
    AssetCreateToJSON,
    AssetDataOutputsPatchAssetDataOutputsBadGatewayErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsBadGatewayErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsBadGatewayErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsBadRequestErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsBadRequestErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsBadRequestErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsGatewayTimeoutErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsGatewayTimeoutErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsGatewayTimeoutErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsInternalServerErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsInternalServerErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsInternalServerErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsMethodNotAllowedErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsMethodNotAllowedErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsMethodNotAllowedErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsNotFoundErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsNotFoundErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsNotFoundErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsNotImplementedErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsNotImplementedErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsNotImplementedErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsRequestBody,
    AssetDataOutputsPatchAssetDataOutputsRequestBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsRequestBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsResponseBody,
    AssetDataOutputsPatchAssetDataOutputsResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsServiceUnavailableErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsServiceUnavailableErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsServiceUnavailableErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsTooManyRequestsErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsTooManyRequestsErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsTooManyRequestsErrorResponseBodyToJSON,
    AssetDataOutputsPatchAssetDataOutputsUnauthorizedErrorResponseBody,
    AssetDataOutputsPatchAssetDataOutputsUnauthorizedErrorResponseBodyFromJSON,
    AssetDataOutputsPatchAssetDataOutputsUnauthorizedErrorResponseBodyToJSON,
    AssetPatch,
    AssetPatchFromJSON,
    AssetPatchToJSON,
    DataInputListResponse,
    DataInputListResponseFromJSON,
    DataInputListResponseToJSON,
    DataInputSnapshotResponse,
    DataInputSnapshotResponseFromJSON,
    DataInputSnapshotResponseToJSON,
    DataInputsTinyResponse,
    DataInputsTinyResponseFromJSON,
    DataInputsTinyResponseToJSON,
    InlineObject3,
    InlineObject3FromJSON,
    InlineObject3ToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2008,
    InlineResponse2008FromJSON,
    InlineResponse2008ToJSON,
    ListIndustrialAssetsResponse,
    ListIndustrialAssetsResponseFromJSON,
    ListIndustrialAssetsResponseToJSON,
    StandardErrorResponse,
    StandardErrorResponseFromJSON,
    StandardErrorResponseToJSON,
    V1MachineHistoryResponse,
    V1MachineHistoryResponseFromJSON,
    V1MachineHistoryResponseToJSON,
    V1VisionRunByCameraResponse,
    V1VisionRunByCameraResponseFromJSON,
    V1VisionRunByCameraResponseToJSON,
    V1VisionRunsByCameraAndProgramResponse,
    V1VisionRunsByCameraAndProgramResponseFromJSON,
    V1VisionRunsByCameraAndProgramResponseToJSON,
    V1VisionRunsResponse,
    V1VisionRunsResponseFromJSON,
    V1VisionRunsResponseToJSON,
} from '../models';

export interface CreateIndustrialAssetRequest {
    asset?: AssetCreate;
}

export interface DeleteIndustrialAssetRequest {
    id: string;
}

export interface GetDataInputDataFeedRequest {
    after?: string;
    parentTagIds?: Array<string>;
    tagIds?: Array<string>;
    dataInputIds?: Array<string>;
    assetIds?: Array<string>;
}

export interface GetDataInputDataHistoryRequest {
    startTime: string;
    endTime: string;
    after?: string;
    parentTagIds?: Array<string>;
    tagIds?: Array<string>;
    dataInputIds?: Array<string>;
    assetIds?: Array<string>;
}

export interface GetDataInputDataSnapshotRequest {
    after?: string;
    parentTagIds?: Array<string>;
    tagIds?: Array<string>;
    dataInputIds?: Array<string>;
    assetIds?: Array<string>;
}

export interface GetDataInputsRequest {
    limit?: number;
    after?: string;
    parentTagIds?: Array<string>;
    tagIds?: Array<string>;
    assetIds?: Array<string>;
}

export interface GetIndustrialAssetsRequest {
    limit?: number;
    after?: string;
    parentTagIds?: Array<string>;
    tagIds?: Array<string>;
    assetIds?: Array<string>;
}

export interface GetVisionRunsByCameraRequest {
    cameraId: number;
    durationMs: number;
    endMs?: number;
}

export interface PatchAssetDataOutputsRequest {
    id: string;
    patchAssetDataOutputsRequestBody: AssetDataOutputsPatchAssetDataOutputsRequestBody;
}

export interface PatchIndustrialAssetRequest {
    id: string;
    asset?: AssetPatch;
}

export interface V1getMachinesHistoryRequest {
    historyParam: InlineObject3;
}

export interface V1getVisionLatestRunCameraRequest {
    cameraId: number;
    programId?: number;
    startedAtMs?: number;
    include?: string;
    limit?: number;
}

export interface V1getVisionProgramsByCameraRequest {
    cameraId: number;
}

export interface V1getVisionRunsRequest {
    durationMs: number;
    endMs?: number;
}

export interface V1getVisionRunsByCameraAndProgramRequest {
    cameraId: number;
    programId: number;
    startedAtMs: number;
    include?: string;
}

/**
 * 
 */
export class IndustrialApi extends runtime.BaseAPI {

    /**
     * Create an asset with optional configuration parameters.
     * Create an asset
     */
    async createIndustrialAssetRaw(requestParameters: CreateIndustrialAssetRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/industrial/assets`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AssetCreateToJSON(requestParameters.asset),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     * Create an asset with optional configuration parameters.
     * Create an asset
     */
    async createIndustrialAsset(requestParameters: CreateIndustrialAssetRequest): Promise<InlineResponse200> {
        const response = await this.createIndustrialAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete asset.
     * Delete an existing asset
     */
    async deleteIndustrialAssetRaw(requestParameters: DeleteIndustrialAssetRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteIndustrialAsset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/industrial/assets/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Delete asset.
     * Delete an existing asset
     */
    async deleteIndustrialAsset(requestParameters: DeleteIndustrialAssetRequest): Promise<string> {
        const response = await this.deleteIndustrialAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Follow a continuous feed of all data input data points.  Your first call to this endpoint will provide you with the most recent data points for each data input and a `pagination` object that contains an `endCursor`.  You can provide the `endCursor` to the `after` parameter of this endpoint to get data point updates since that `endCursor`.  If `hasNextPage` is `false`, no updates are readily available yet. We suggest waiting a minimum of 5 seconds before requesting updates.
     * Follow a real-time feed of data points for data inputs
     */
    async getDataInputDataFeedRaw(requestParameters: GetDataInputDataFeedRequest): Promise<runtime.ApiResponse<DataInputListResponse>> {
        const queryParameters: any = {};

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.parentTagIds) {
            queryParameters['parentTagIds'] = requestParameters.parentTagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tagIds) {
            queryParameters['tagIds'] = requestParameters.tagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.dataInputIds) {
            queryParameters['dataInputIds'] = requestParameters.dataInputIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.assetIds) {
            queryParameters['assetIds'] = requestParameters.assetIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/industrial/data-inputs/data-points/feed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DataInputListResponseFromJSON(jsonValue));
    }

    /**
     * Follow a continuous feed of all data input data points.  Your first call to this endpoint will provide you with the most recent data points for each data input and a `pagination` object that contains an `endCursor`.  You can provide the `endCursor` to the `after` parameter of this endpoint to get data point updates since that `endCursor`.  If `hasNextPage` is `false`, no updates are readily available yet. We suggest waiting a minimum of 5 seconds before requesting updates.
     * Follow a real-time feed of data points for data inputs
     */
    async getDataInputDataFeed(requestParameters: GetDataInputDataFeedRequest): Promise<DataInputListResponse> {
        const response = await this.getDataInputDataFeedRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns all known data points during the given time range for all data inputs. This can be filtered by optional tags, specific data input IDs or asset IDs.
     * List historical data points for data inputs
     */
    async getDataInputDataHistoryRaw(requestParameters: GetDataInputDataHistoryRequest): Promise<runtime.ApiResponse<DataInputListResponse>> {
        if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
            throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling getDataInputDataHistory.');
        }

        if (requestParameters.endTime === null || requestParameters.endTime === undefined) {
            throw new runtime.RequiredError('endTime','Required parameter requestParameters.endTime was null or undefined when calling getDataInputDataHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.startTime !== undefined) {
            queryParameters['startTime'] = requestParameters.startTime;
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['endTime'] = requestParameters.endTime;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.parentTagIds) {
            queryParameters['parentTagIds'] = requestParameters.parentTagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tagIds) {
            queryParameters['tagIds'] = requestParameters.tagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.dataInputIds) {
            queryParameters['dataInputIds'] = requestParameters.dataInputIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.assetIds) {
            queryParameters['assetIds'] = requestParameters.assetIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/industrial/data-inputs/data-points/history`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DataInputListResponseFromJSON(jsonValue));
    }

    /**
     * Returns all known data points during the given time range for all data inputs. This can be filtered by optional tags, specific data input IDs or asset IDs.
     * List historical data points for data inputs
     */
    async getDataInputDataHistory(requestParameters: GetDataInputDataHistoryRequest): Promise<DataInputListResponse> {
        const response = await this.getDataInputDataHistoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns last known data points for all data inputs. This can be filtered by optional tags, specific data input IDs or asset IDs.
     * List most recent data points for data inputs
     */
    async getDataInputDataSnapshotRaw(requestParameters: GetDataInputDataSnapshotRequest): Promise<runtime.ApiResponse<DataInputSnapshotResponse>> {
        const queryParameters: any = {};

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.parentTagIds) {
            queryParameters['parentTagIds'] = requestParameters.parentTagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tagIds) {
            queryParameters['tagIds'] = requestParameters.tagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.dataInputIds) {
            queryParameters['dataInputIds'] = requestParameters.dataInputIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.assetIds) {
            queryParameters['assetIds'] = requestParameters.assetIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/industrial/data-inputs/data-points`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DataInputSnapshotResponseFromJSON(jsonValue));
    }

    /**
     * Returns last known data points for all data inputs. This can be filtered by optional tags, specific data input IDs or asset IDs.
     * List most recent data points for data inputs
     */
    async getDataInputDataSnapshot(requestParameters: GetDataInputDataSnapshotRequest): Promise<DataInputSnapshotResponse> {
        const response = await this.getDataInputDataSnapshotRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns all data inputs, optionally filtered by tags or asset ids.
     * List all data inputs
     */
    async getDataInputsRaw(requestParameters: GetDataInputsRequest): Promise<runtime.ApiResponse<DataInputsTinyResponse>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.parentTagIds) {
            queryParameters['parentTagIds'] = requestParameters.parentTagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tagIds) {
            queryParameters['tagIds'] = requestParameters.tagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.assetIds) {
            queryParameters['assetIds'] = requestParameters.assetIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/industrial/data-inputs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DataInputsTinyResponseFromJSON(jsonValue));
    }

    /**
     * Returns all data inputs, optionally filtered by tags or asset ids.
     * List all data inputs
     */
    async getDataInputs(requestParameters: GetDataInputsRequest): Promise<DataInputsTinyResponse> {
        const response = await this.getDataInputsRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all assets in the organization.
     * List all assets
     */
    async getIndustrialAssetsRaw(requestParameters: GetIndustrialAssetsRequest): Promise<runtime.ApiResponse<ListIndustrialAssetsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.parentTagIds) {
            queryParameters['parentTagIds'] = requestParameters.parentTagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tagIds) {
            queryParameters['tagIds'] = requestParameters.tagIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.assetIds) {
            queryParameters['assetIds'] = requestParameters.assetIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/industrial/assets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ListIndustrialAssetsResponseFromJSON(jsonValue));
    }

    /**
     * List all assets in the organization.
     * List all assets
     */
    async getIndustrialAssets(requestParameters: GetIndustrialAssetsRequest): Promise<ListIndustrialAssetsResponse> {
        const response = await this.getIndustrialAssetsRaw(requestParameters);
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch runs by camera.
     * Fetch runs by camera
     */
    async getVisionRunsByCameraRaw(requestParameters: GetVisionRunsByCameraRequest): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters.cameraId === null || requestParameters.cameraId === undefined) {
            throw new runtime.RequiredError('cameraId','Required parameter requestParameters.cameraId was null or undefined when calling getVisionRunsByCamera.');
        }

        if (requestParameters.durationMs === null || requestParameters.durationMs === undefined) {
            throw new runtime.RequiredError('durationMs','Required parameter requestParameters.durationMs was null or undefined when calling getVisionRunsByCamera.');
        }

        const queryParameters: any = {};

        if (requestParameters.durationMs !== undefined) {
            queryParameters['durationMs'] = requestParameters.durationMs;
        }

        if (requestParameters.endMs !== undefined) {
            queryParameters['endMs'] = requestParameters.endMs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/industrial/vision/runs/{camera_id}`.replace(`{${"camera_id"}}`, encodeURIComponent(String(requestParameters.cameraId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch runs by camera.
     * Fetch runs by camera
     */
    async getVisionRunsByCamera(requestParameters: GetVisionRunsByCameraRequest): Promise<Array<object>> {
        const response = await this.getVisionRunsByCameraRaw(requestParameters);
        return await response.value();
    }

    /**
     * Writes values to multiple data outputs on an asset simultaneously. Only the provided data outputs will be updated.
     * Writes to data outputs on an asset
     */
    async patchAssetDataOutputsRaw(requestParameters: PatchAssetDataOutputsRequest): Promise<runtime.ApiResponse<AssetDataOutputsPatchAssetDataOutputsResponseBody>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling patchAssetDataOutputs.');
        }

        if (requestParameters.patchAssetDataOutputsRequestBody === null || requestParameters.patchAssetDataOutputsRequestBody === undefined) {
            throw new runtime.RequiredError('patchAssetDataOutputsRequestBody','Required parameter requestParameters.patchAssetDataOutputsRequestBody was null or undefined when calling patchAssetDataOutputs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/industrial/assets/{id}/data-outputs`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AssetDataOutputsPatchAssetDataOutputsRequestBodyToJSON(requestParameters.patchAssetDataOutputsRequestBody),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetDataOutputsPatchAssetDataOutputsResponseBodyFromJSON(jsonValue));
    }

    /**
     * Writes values to multiple data outputs on an asset simultaneously. Only the provided data outputs will be updated.
     * Writes to data outputs on an asset
     */
    async patchAssetDataOutputs(requestParameters: PatchAssetDataOutputsRequest): Promise<AssetDataOutputsPatchAssetDataOutputsResponseBody> {
        const response = await this.patchAssetDataOutputsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an existing asset. Only the provided fields will be updated.
     * Update an asset
     */
    async patchIndustrialAssetRaw(requestParameters: PatchIndustrialAssetRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling patchIndustrialAsset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/industrial/assets/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AssetPatchToJSON(requestParameters.asset),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     * Update an existing asset. Only the provided fields will be updated.
     * Update an asset
     */
    async patchIndustrialAsset(requestParameters: PatchIndustrialAssetRequest): Promise<InlineResponse200> {
        const response = await this.patchIndustrialAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch all cameras.
     * Fetch industrial cameras
     */
    async v1getCamerasRaw(): Promise<runtime.ApiResponse<Array<object>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/industrial/vision/cameras`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch all cameras.
     * Fetch industrial cameras
     */
    async v1getCameras(): Promise<Array<object>> {
        const response = await this.v1getCamerasRaw();
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Get machine objects. This method returns a list of the machine objects in the Samsara Cloud and information about them.
     * Get machines
     */
    async v1getMachinesRaw(): Promise<runtime.ApiResponse<InlineResponse2008>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/machines/list`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2008FromJSON(jsonValue));
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Get machine objects. This method returns a list of the machine objects in the Samsara Cloud and information about them.
     * Get machines
     */
    async v1getMachines(): Promise<InlineResponse2008> {
        const response = await this.v1getMachinesRaw();
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Get historical data for machine objects. This method returns a set of historical data for all machines.
     * Get machine history
     */
    async v1getMachinesHistoryRaw(requestParameters: V1getMachinesHistoryRequest): Promise<runtime.ApiResponse<V1MachineHistoryResponse>> {
        if (requestParameters.historyParam === null || requestParameters.historyParam === undefined) {
            throw new runtime.RequiredError('historyParam','Required parameter requestParameters.historyParam was null or undefined when calling v1getMachinesHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/machines/history`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject3ToJSON(requestParameters.historyParam),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1MachineHistoryResponseFromJSON(jsonValue));
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Get historical data for machine objects. This method returns a set of historical data for all machines.
     * Get machine history
     */
    async v1getMachinesHistory(requestParameters: V1getMachinesHistoryRequest): Promise<V1MachineHistoryResponse> {
        const response = await this.v1getMachinesHistoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetch the latest run for a camera or program by default. If startedAtMs is supplied, fetch the specific run that corresponds to that start time.
     * Fetch the latest run for a camera or program
     */
    async v1getVisionLatestRunCameraRaw(requestParameters: V1getVisionLatestRunCameraRequest): Promise<runtime.ApiResponse<V1VisionRunByCameraResponse>> {
        if (requestParameters.cameraId === null || requestParameters.cameraId === undefined) {
            throw new runtime.RequiredError('cameraId','Required parameter requestParameters.cameraId was null or undefined when calling v1getVisionLatestRunCamera.');
        }

        const queryParameters: any = {};

        if (requestParameters.programId !== undefined) {
            queryParameters['program_id'] = requestParameters.programId;
        }

        if (requestParameters.startedAtMs !== undefined) {
            queryParameters['startedAtMs'] = requestParameters.startedAtMs;
        }

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/industrial/vision/run/camera/{camera_id}`.replace(`{${"camera_id"}}`, encodeURIComponent(String(requestParameters.cameraId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VisionRunByCameraResponseFromJSON(jsonValue));
    }

    /**
     * Fetch the latest run for a camera or program by default. If startedAtMs is supplied, fetch the specific run that corresponds to that start time.
     * Fetch the latest run for a camera or program
     */
    async v1getVisionLatestRunCamera(requestParameters: V1getVisionLatestRunCameraRequest): Promise<V1VisionRunByCameraResponse> {
        const response = await this.v1getVisionLatestRunCameraRaw(requestParameters);
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch configured programs on the camera.
     * Fetch industrial camera programs
     */
    async v1getVisionProgramsByCameraRaw(requestParameters: V1getVisionProgramsByCameraRequest): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters.cameraId === null || requestParameters.cameraId === undefined) {
            throw new runtime.RequiredError('cameraId','Required parameter requestParameters.cameraId was null or undefined when calling v1getVisionProgramsByCamera.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/industrial/vision/cameras/{camera_id}/programs`.replace(`{${"camera_id"}}`, encodeURIComponent(String(requestParameters.cameraId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch configured programs on the camera.
     * Fetch industrial camera programs
     */
    async v1getVisionProgramsByCamera(requestParameters: V1getVisionProgramsByCameraRequest): Promise<Array<object>> {
        const response = await this.v1getVisionProgramsByCameraRaw(requestParameters);
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch runs.
     * Fetch runs
     */
    async v1getVisionRunsRaw(requestParameters: V1getVisionRunsRequest): Promise<runtime.ApiResponse<V1VisionRunsResponse>> {
        if (requestParameters.durationMs === null || requestParameters.durationMs === undefined) {
            throw new runtime.RequiredError('durationMs','Required parameter requestParameters.durationMs was null or undefined when calling v1getVisionRuns.');
        }

        const queryParameters: any = {};

        if (requestParameters.durationMs !== undefined) {
            queryParameters['durationMs'] = requestParameters.durationMs;
        }

        if (requestParameters.endMs !== undefined) {
            queryParameters['endMs'] = requestParameters.endMs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/industrial/vision/runs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VisionRunsResponseFromJSON(jsonValue));
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch runs.
     * Fetch runs
     */
    async v1getVisionRuns(requestParameters: V1getVisionRunsRequest): Promise<V1VisionRunsResponse> {
        const response = await this.v1getVisionRunsRaw(requestParameters);
        return await response.value();
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch runs by camera and program.
     * Fetch runs by camera and program
     */
    async v1getVisionRunsByCameraAndProgramRaw(requestParameters: V1getVisionRunsByCameraAndProgramRequest): Promise<runtime.ApiResponse<V1VisionRunsByCameraAndProgramResponse>> {
        if (requestParameters.cameraId === null || requestParameters.cameraId === undefined) {
            throw new runtime.RequiredError('cameraId','Required parameter requestParameters.cameraId was null or undefined when calling v1getVisionRunsByCameraAndProgram.');
        }

        if (requestParameters.programId === null || requestParameters.programId === undefined) {
            throw new runtime.RequiredError('programId','Required parameter requestParameters.programId was null or undefined when calling v1getVisionRunsByCameraAndProgram.');
        }

        if (requestParameters.startedAtMs === null || requestParameters.startedAtMs === undefined) {
            throw new runtime.RequiredError('startedAtMs','Required parameter requestParameters.startedAtMs was null or undefined when calling v1getVisionRunsByCameraAndProgram.');
        }

        const queryParameters: any = {};

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/industrial/vision/runs/{camera_id}/{program_id}/{started_at_ms}`.replace(`{${"camera_id"}}`, encodeURIComponent(String(requestParameters.cameraId))).replace(`{${"program_id"}}`, encodeURIComponent(String(requestParameters.programId))).replace(`{${"started_at_ms"}}`, encodeURIComponent(String(requestParameters.startedAtMs))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1VisionRunsByCameraAndProgramResponseFromJSON(jsonValue));
    }

    /**
     * <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> This endpoint is still on our legacy API. </nh> </n>  Fetch runs by camera and program.
     * Fetch runs by camera and program
     */
    async v1getVisionRunsByCameraAndProgram(requestParameters: V1getVisionRunsByCameraAndProgramRequest): Promise<V1VisionRunsByCameraAndProgramResponse> {
        const response = await this.v1getVisionRunsByCameraAndProgramRaw(requestParameters);
        return await response.value();
    }

}
